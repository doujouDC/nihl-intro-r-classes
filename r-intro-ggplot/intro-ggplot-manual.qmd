---
title: "Introduction to ggplot"
author: "Doug Joubert"
author: "Doug Joubert"
date: "`r Sys.Date()`"
format: docx
editor: visual
toc: true
toc-location: body
fig-width: 6
fig-height: 4
bibliography: nihl-r-classes.bib
csl: apa.csl
---

# Learning Objectives

By the end of this section, students should be able to:

1.  Discuss the connection between data, aesthetics, & the grammar of graphics
2.  Outline the grammatical layers in ggplot
3.  Label the basic elements of a graph
4.  Distinguish between "viewing" a graph in R and saving a graph in R.

# Semiotics of Graphics

Semiotics is the study of symbols and how they convey meaning. In his great masterwork, Semiology of Graphics, Bertin (1983) attempted to classify all graphic marks in terms of how they could express data.

For the most part, this work is based on his own judgment, although it is a highly trained and sensitive judgment. There are few references to theories of perception or scientific studies.

![](images/three-symbols-visual.png) Figure 1: Examples of different visual "languages" [@RN1346].

The first example of visual language is based on a cave painting. We can readily interpret that these are animal.

The second example is a schematic diagram showing the interaction between lab equipment and some sort of medium.

The third example is the expression of a mathematical equation that is utterly obscure to all but the initiated.

These examples clearly show that some visual languages are easier to "read" than others. But why?

-   Perhaps it is simply that we have more experience with the kind of pictorial image shown in the cave painting and less with the mathematical notation.

-   Perhaps the concepts expressed in the cave painting are more familiar than those in the equation.

# Coordinate systems and axes

To make any sort of data visualization, we need to define position scales, which determine where in a graphic different data values are located [@RN1397]. We cannot visualize data without placing different data points at different locations, even if we just arrange them next to each other along a line.

In 2D visualizations, two numbers are required to uniquely specify a point, and therefore we need two position scales [@RN1397]. These two scales are usually the x and y axes of the plot [@RN1397]. We also have to specify the relative geometric arrangement of these scales [@RN1397].

## Cartesian Coordinates

The most widely used coordinate system for data visualization is the 2D Cartesian coordinate system, where each location is uniquely specified by an x and a y value [@RN1397]. As illustrated in Figure 2, the data values are placed in an even spacing along both axes, the two axes are continuous position scales, and they can represent both positive and negative real numbers [@RN1397].

![](ggplot-images/cartesian-coord-1.png){width="4.5in"}

Figure 2: Standard Cartesian coordinate system [@RN1397].

In Figure 2, both the x and the y grid lines are separated by units of one, and the x axis runs from -2.2 to 3.2 and the y axis runs from -2.2 to 2.2 [@RN1397]. Any data values between these axis limits are placed at the respective location in the plot. Any data values outside the axis limits are discarded [@RN1397].

It is important to remember that data values usually aren't just numbers, they come with units [@RN1397]. For example, if we're measuring temperature, the values may be measured in degrees Celsius or Fahrenheit [@RN1397]. Similarly, if we're measuring distance, the values may be measured in kilometers or miles [@RN1397].

You may wonder what happens if you change the units of your data. A change in units is a linear transformation, where we add or subtract a number to or from all data values and/or multiply all data values with another number [@RN1397].

Therefore, you can change the units of your data and the resulting figure will not change if you change the axes accordingly. As an example, compare how the data is displayed in Figures 3 (a) and 3 (b).

![](images/temperature-normals-Houston-San-Diego-1.png)

Figure 3: Daily (normal) temperature for Houston, TX, plotted versus the (normal) temperature of San Diego, CA (Wilke, 2019). Data source: NOAA.

## Nonlinear Axes and Log Transformations

In a Cartesian coordinate system, the grid lines along an axis are spaced evenly both in data units and in the resulting visualization. We refer to the position scales in these coordinate systems as linear [@RN1397].

There are scenarios where nonlinear scales are preferred. The most used nonlinear scale is the logarithmic scale, or log scale for short [@RN1397]. Log scales are linear in multiplication, such that a unit step on the scale corresponds to multiplication with a fixed value [@RN1397].

Importantly, the correct axis title for a logarithmic scale is the name of the variable shown, not the logarithm of that variable.

It is always recommended that you verify the base when working with log-transformed data [@RN1397]. When plotting log-transformed data, always specify the base in the labeling of the axis, to avoid confusion.

Log scales are the natural choice for any data that has been obtained by multiplication or division. For example, ratios should generally be shown on a log scale [@RN1397]. As an example, in Figure 4, the number of inhabitants in each county in Texas was divided by the median number of inhabitants across all Texas counties \[Figure 4\].

![](images/texas-counties-pop-ratio-log-1.png) [@RN1397]

Figure 4: Texas counties, from most to least populous using a log scale 10 transformation [@RN1397].

Look how different the same data appears when graph using a linear scale. Using a linear scale obscures the differences between a county with median population number and a county with a much smaller population number than median \[Figure 5\] [@RN1397].

![](images/texas-counties-pop-ratio-lin-1.png)

Figure 5: Texas counties, from most to least populous, using a linear transformation (Wilke, 2019).

Log scales are frequently used when the dataset contains numbers of very different magnitudes [@RN1397]. For the Texas counties shown in Figures 4 and 5, the most populous one (Harris) had 4,092,459 inhabitants in the 2010 US Census while the least populous one (Loving) had 82 [@RN1397]. So, a log scale would be appropriate even if we hadn't divided the population numbers by their median to turn them into ratios [@RN1397].

# Loading our Packages

## Tidyverse Package

For this lesson we will use the gapminder data to make our first plots. So we need to make sure the library containing the data is loaded, along with the tidyverse. A brief definition of each package is provided below:

The tidyverse is an opinionated [**collection of R packages**](https://www.tidyverse.org/packages) designed for data science. All packages share an underlying design philosophy, grammar, and data structures.

Install the complete tidyverse with:

    install.packages("tidyverse")

## Gapminder Package

Excerpt from the [**Gapminder**](http://www.gapminder.org/data/) data. The main object in this package is the **`gapminder`** data frame or "tibble". There are other goodies, such as the data in tab delimited form, a larger unfiltered dataset, premade color schemes for the countries and continents, and ISO 3166-1 country codes.

The **`gapminder`** data frames include six variables, ([**Gapminder.org documentation page**](http://www.gapminder.org/data/documentation/)).

Install the gapminder package with:

    install.packages("gapminder")

The **nlme: Nonlinear Mixed-Effects Models** package fits a nonlinear mixed-effects model in the formulation described in Lindstrom and Bates (1990) but allowing for nested random effects. The within-group errors are allowed to be correlated and/or have unequal variances. We are simply using it for the [oxboys](https://rdrr.io/cran/mlmRev/man/Oxboys.html) dataset.

Now, we can load the packages

```{r}
#| output: false
library(tidyverse)
library(gapminder)
library(nlme)
```

# How ggplot Works

ggplot is built on the grammar of graphics, the idea that any plot can be expressed from the same set of components:

1.  Data set, which is simply a column or columns in you dataset
2.  Coordinate system
3.  Aesthetic attributes of ggplot to display the visual property of your graph. For example the position, shape, or color elements on the graph
4.  Set of geoms, the visual representation of data points.

Figure 6 is displaying the first and second elements of ggplot's grammar of graphics. We will go through these steps in detail.

![](images/healy-ggplot-vertical-flow-01.png){width="3.55in"}

Figure 6: Schematic of how ggplot works: Data to mapping.

Figure 7 is displaying the third and fourth elements of ggplot's grammar of graphics

![](images/healy-ggplot-vertical-flow-02.png){width="3.52in"}

Figure 7: Schematic of how ggplot works: geom to scales.

And last, Figure 8 is displaying the final set elements of ggplot's grammar of graphics.

![](images/healy-ggplot-vertical-flow-03.png){width="3.95in"}

Figure 8: Schematic of how ggplot works: adding labels and guides.

The most important thing to get used is mapping out the logical structure of your plot [@RN1461]. The code you write specifies the connections between the variables in your data, and the colors, points, and shapes you see on the screen [@RN1461].

In ggplot, these logical connections between your data and the plot elements are called aesthetic mappings or just aesthetics [@RN1461]. You begin every plot by telling the `ggplot()` function what your data is and how the variables in this data logically map onto the plot's aesthetics [@RN1461].

To build a ggplot, we will use a basic template that can be used for different types of plots.

`ggplot(data = DATA, mapping = aes(AESTHETIC MAPPINGS)) + geom_function()`

## ggplot

We start by defining the dataset we'll use, lay out the axes, and choose a geom. To build a ggplot, we will use the following basic template that can be used for different types of plots:

You begin every plot by telling the `ggplot()` function what your data is. We will be implementing this using pipes.

```{r}
gapminder %>% 
  ggplot()
```

### Notes About the ggplot() Function

-   Anything you put in the `ggplot()` function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x-axis and y-axis mapping you set up in `aes()`.
-   You can also specify mappings for a given geom independently of the mappings defined globally in the `ggplot()` function.
-   The + sign used to add new layers **must be placed at the end of the line containing the previous layer.** If, instead, the + sign is added at the beginning of the line containing the new layer, ggplot2 will not add the new layer and will return an error message.

At this point ggplot knows our data but not the mapping. That is, we need to tell it which variables in the data should be represented by which visual elements in the plot. It also doesn't know what sort of plot we want.

## Defining Plot Aesthetics

Each geom function in ggplot2 takes a mapping argument, `mapping =`.

This defines how variables in your dataset are mapped to visual properties. The mapping argument is always paired with `aes()`:

`mapping = aes()`

`aes()` allows us to select the variables to be plotted and specify how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, or color.

Let us add `aes()` to our plot. Before we do this, let us take a peek at the data.

```{r}
#| output: false
glimpse(gapminder)
```

We are going to plot the following variables from the nyc data, which we will place inside the mapping function. Let us plot `lifeExp` against `gdpPercap`.

Let us add `aes()` to our plot. We are going to plot the following variables, which we will place inside the (x = gdpPercap, y = lifeExp), and save this to the p object.

```{r}
gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp))
```

As we can see in the output above, `aes()` allows us to select the variables to be plotted and specify how to present them in the graph. As we can see from the output, the `ggplot()` function and already has information in it about the mappings we want, together with a lot of other information added by default [@RN1461].

So what have we done so far?

-   We have provided the `ggplot()` function two arguments: data and mapping. The data argument tells ggplot where to find the variables it is about to use. This saves us from having to tediously dig out the name of each variable in full.

-   Next, we supplied the `mapping` function. So, `mapping = aes(x = gdpPercap, y = lifeExp)` says that the variable on the x-axis is going to be `gdpPercap`, and the variable on the y-axis is going to be `lifeExp`. The `aes() function` does not say where variables with those names are to be found. That's because ggplot() assumes that this comes from object given to the data argument [@RN1461].

The `mapping=aes()` argument links variables to things you will see on the plot [@RN1461]. The x and y values are the most obvious ones. However, other aesthetic mappings can include, color, shape, size, and line type (whether a line is solid, dashed) [@RN1461].

A mapping does not say what particular colors or shapes will be on the plot. Rather it says which variables in the data will be represented by visual elements like a color, a shape, or a point on the plot area [@RN1461].

# Geoms in ggplot

ADD SOME INTRO INFORMATION ABOUT STARTING TO ADD LAYERS ETC

## Correct Method for Adding a Layer

The plus symbol + must be added to each new layer that you add to plot syntax. The plus sign + must be placed at the end of each line of code.

### Correct syntax for adding layers

`ggplot(data = gapminder)`

### Incorrect Method for Adding a Layer

This will not add the new layer and will return an error message

`surveys_plot + geom_point()`

## Individual geoms

The geoms listed below are the fundamental building blocks of ggplot2. They are useful in their own right, but are also used to construct more complex geoms. Most of these geoms are associated with a named plot: when that geom is used by itself in a plot, that plot has a special name.

Each of these geoms is two dimensional and requires both `x` and `y` aesthetics. All of them understand `colour` (or `color`) and `size` aesthetics, and the filled geoms (bar, tile and polygon) also understand `fill`.

-   [`geom_area()`](https://ggplot2.tidyverse.org/reference/geom_ribbon.html) draws an **area plot**, which is a line plot filled to the y-axis (filled lines). Multiple groups will be stacked on top of each other.

-   [`geom_bar(stat = "identity")`](https://ggplot2-book.org/statistical-summaries.html#distributions) makes a **bar chart**. We need `stat = "identity"` because the default stat automatically counts values (so is essentially a 1d geom, see Section [5.4](https://ggplot2-book.org/statistical-summaries.html#distributions). The identity stat leaves the data unchanged. Multiple bars in the same location will be stacked on top of one another.

-   [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) makes a **line plot**. The `group` aesthetic determines which observations are connected; see Chapter [4](https://ggplot2-book.org/collective-geoms.html#collective-geoms) for more detail. [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) connects points from left to right; [`geom_path()`](https://ggplot2.tidyverse.org/reference/geom_path.html) is similar but connects points in the order they appear in the data. Both [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) and [`geom_path()`](https://ggplot2.tidyverse.org/reference/geom_path.html) also understand the aesthetic `linetype`, which maps a categorical variable to solid, dotted and dashed lines.

-   [`geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) produces a **scatterplot**. [`geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) also understands the `shape` aesthetic.

-   [`geom_polygon()`](https://ggplot2.tidyverse.org/reference/geom_polygon.html) draws polygons, which are filled paths. Each vertex of the polygon requires a separate row in the data. It is often useful to merge a data frame of polygon coordinates with the data just prior to plotting. Section [6](https://ggplot2-book.org/maps.html#maps) illustrates this concept in more detail for map data.

-   [`geom_rect()`](https://ggplot2.tidyverse.org/reference/geom_tile.html), [`geom_tile()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) and [`geom_raster()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) draw rectangles. [`geom_rect()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) is parameterised by the four corners of the rectangle, `xmin`, `ymin`, `xmax` and `ymax`. [`geom_tile()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) is exactly the same, but parameterised by the center of the rect and its size, `x`, `y`, `width` and `height`. [`geom_raster()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) is a fast special case of [`geom_tile()`](https://ggplot2.tidyverse.org/reference/geom_tile.html) used when all the tiles are the same size.

So, a basic plot might looks something like this

```{r}
gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp)) +
  geom_point()
```

If we want to map the data to the different aesthetics, it might look like this.

| **Data**                 | **Variable** | **aes** | **geom**   |
|--------------------------|--------------|---------|------------|
| Weatlh (GGP/capita)      | gdpPercap    | x       | geom_point |
| Health (Life Expectancy) | lifeExp      | y       | geom_point |
| Continent                | country      | Color   | geom_point |
| Population               | pop          | Size    | geom_point |

```{r}
gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +
  geom_point() +
  scale_x_log10() # changes x-axis to be on the log scale, because of
# gaps in countries
```

## Collective Geoms in ggplot

An **individual** `geom` draws a distinct graphical object for each observation (row). For example, the point geom draws one point per row. A **collective** `geom` displays multiple observations with one geometric object. This may be a result of a statistical summary, like a boxplot, or may be fundamental to the display of the geom, like a polygon. How do we control the assignment of observations to graphical elements? This is the job of the `group` aesthetic.

By default, the `group` aesthetic is mapped to the interaction of all discrete variables in the plot. This often partitions the data correctly. However, when the mapping is not automatic, or when no discrete variable is used in a plot, you'll need to explicitly define the grouping structure to a variable that has a different value for each group.

In the following examples, we will use a simple longitudinal dataset, [Oxboys](https://rdrr.io/cran/nlme/man/Oxboys.html) which is included in the `nlme`package. It looks at the height of a selection of boys from Oxford, England versus a standardized age. It records the heights (`height`) and centered ages (`age`) of 26 boys (`Subject`), measured on nine occasions (`Occasion`). `Subject` and `Occassion` are stored as ordered factors.

```{r}
#| output: false
glimpse(Oxboys)
```

### Multiple groups, one aesthetic

In many situations, you want to separate your data into groups, but render them in the same way. In other words, you want to be able to distinguish individual subjects, but not identify them. This is common in longitudinal studies with many subjects, where the plots are often descriptively called spaghetti plots. For example, the following plot shows the growth trajectory for each boy (each `Subject`). Without grouping, ggplot will make its best judgement, when displaying the graph

```{r}
Oxboys %>%
  ggplot(mapping = aes(x = age, y = height)) + 
  geom_line()
```

This is certainly not what we want, and we get a graph that has a saw tooth appearance:

```{r}
Oxboys %>% 
ggplot(mapping = aes(x = age, y = height, group = Subject)) + 
  geom_line()
```

## Different groups on different layers

Sometimes we want to plot summaries that use different levels of aggregation: one layer might display individuals, while another displays an overall summary. Building on the previous example, suppose we want to add a single smooth line, showing the overall trend for all boys. If we use the same grouping in both layers, we get one smooth line per boy:

```{r}
Oxboys %>% 
ggplot(mapping = aes(x = age, y = height, group = Subject)) + 
  geom_line() + 
  geom_smooth(method = "lm", se = FALSE)
```

This is not what we wanted; we have added a smoothed line for each boy. Grouping controls both the display of the geoms, and the operation of the stats: one statistical transformation is run for each group.

Instead of setting the grouping aesthetic in [`ggplot()`](https://ggplot2.tidyverse.org/reference/ggplot.html), where it will apply to all layers, we set it in [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) so it applies only to the lines. There are no discrete variables in the plot so the default grouping variable will be a constant and we get one smooth.

```{r}
ggplot(Oxboys, aes(age, height)) + 
  geom_line(aes(group = Subject)) + 
  geom_smooth(method = "lm", size = 2, se = FALSE)
```

# NEW CONTENT FROM BONUS LECTURE Geoms in ggplot

Next, we need to add a layer to the plot. This means picking a geom\_ function. We will use geom_point().

p +

  geom_point()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image005.png)

Figure 6.25: Plot with the geom added.

# Build Your Plots Layer by Layer

The general structure of the code that is used to plot figures is as follows:

    ggplot(...)+ # Initialization
    geom_function(...)+ # Main plot(s)
    facet_function(...)+ # Facets (optional)
    labs(...)+ #  Legend (optional)
    scale_function(...) + # Scales (optional)
    theme_function(...) # Theme (optional)

What to consider, when working with these layers:

-   The `ggplot()` layer is mandatory.

-   When the `data` argument is specified inside the `ggplot()` function, it is used as default in the following layers that compose the plot command, unless otherwise specified.

-   In order for features of a data frame to be used in a plot, they need to be specified inside the `aes()` function.

We just went through the basics of building up plots, layer by layer. We began with creating a mapping between a variable and an aesthetic element. The good news is that, from now on, not much will change conceptually about what we are doing (Healy, 2018).

We will start with a table of data that has been tidied, and then we will do the following:

1.  Using data = (), tell the ggplot() function define our dataset.

2.  Using mapping = aes(), tell ggplot() *what* relationships we want to see on the plot. For convenience we will put the results of the first two steps in an object called p.

3.  Tell ggplot *how* we want to see the relationships in our data by defining the xand yaxes.

4.  Using + layer on geoms as needed, by adding them to the pobject one at a time.

5.  Use some additional functions to adjust the scales, labels, tick marks, and titles.

It is important to note that you usually cannot add functions to objects, in R (Healy, 2018). Outside of ggplot, functions take objects as inputs and produce objects as outputs (Healy, 2018). This functionality of ggplot() makes it easier to assemble plots one piece at a time, and to inspect how they look at every step (Healy, 2018). For example, let's try a different geom\_ function with our plot \[Figure 6.26\].

p +

geom_smooth()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image006.png)

Figure 6.26: Life expectancy vs GDP, using a smoother.

As we can see, some geoms do a lot more than simply put points on a grid. Here the geom_smooth() has calculated a smoothed line for us and shaded in a ribbon showing the standard error for the line (Healy, 2018). If we want to see the data points and the line together, we simply add the geom_point() back in Figure 6.27:

p +

  geom_point() +

  geom_smooth()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image007.png)

Figure Figure 6.28: Life expectancy vs GDP, showing both points and a GAM smoother.

For figures L4.27 and L4.28 we did not have to tell geom_point() or geom_smooth()where their data was coming from, or what mappings they should use. They inherit this information from the original p object (Healy, 2018). As we'll see later, it's possible to give geoms separate instructions that they will follow. However, in the absence of any other information, the geoms will look for the instructions they need in the ggplot() function, or the object created by it (Healy, 2018).

# Mapping Aesthetics vs Setting Them

An *aesthetic mapping* specifies that a variable will be expressed by one of the available visual elements, such as size, or color, or shape. For example:

p \<- ggplot(data = gapminder , mapping = aes(x = gdpPercap, y = lifeExp, color = continent))

What happens when we graph this?

p + geom_point()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image008.png)

Figure 6.29: Mapping the continent variable to the color aesthetic.

In Figure 6.29, the individual data points have been colored by continent, and a legend with a key to the colors has automatically been added to the plot. There is one for each unique value of the continent variable.

How do you think this code will be interpreted, when graphed?

p \<- ggplot(data = gapminder , mapping = aes(x = gdpPercap, y = lifeExp, color = "purple"))

p + geom_point()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image009.png)

Figure 6.30: What has gone wrong here?

Why is there a legend saying "purple," and why have the points all turned pinkish-red instead of purple (Healy, 2018)? The aes () function is where that mapping is specified, and the function is trying to do its job (Healy, 2018). It wants to map a variable to the color aesthetic, so it assumes you are giving it a variable (Healy, 2018). aes() will do its best to treat "purple" as though it were a variable (Healy, 2018).

If we want to set a property, like color, we do it in the geom\_ we are using, and outside the mapping =aes (...) step. For example:

p \<- ggplot(data = gapminder , mapping = aes(x = gdpPercap, y = lifeExp)) p + geom_point(color = "purple")

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image010.png)

Figure 6.31: Setting the color attribute of the points directly.

# Aesthetics Can Be Mapped per Geom

By default, geoms inherit their mappings from the ggplot() function. We can change this by specifying different aesthetics for each geom. To do this, we use the same mapping = aes(...) expression. However, this time we use it in the geom\_ functions.

p \<- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp))

Mappings specified in the initial ggplot( ) function (x and y) will carry through to all subsequent geoms.

p + geom_point(mapping = aes(color = continent)) + geom_smooth(method = "loess") + scale_x\_log10()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image011.png)

Figure 6.32: Mapping aesthetics on a per geom basis.

As you can see in Figure 6.32, color is mapped to the continent variable for the points but not the smoother.

Finally, it is worth paying a little more attention to the way that ggplot draws its scales (Healy, 2018). Because every mapped variable has a scale, we can learn a lot about how a plot has been constructed, by seeing what the legends look like (Healy, 2018). For example:

p \<- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp, color = continent, fill = continent))

p + geom_point() +

geom_smooth(method = "loess") + scale_x\_log10()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image012.png)

Figure 6.33: Mapping the continent variable to the color aesthetic, and correcting the error bars using the fill aesthetic.

In Figure 6.33, we mapped the continent variable to both color and fill. We then drew the figure with geom_point()and fitted a line for each continent with geom_smooth (). Points have color but the smoother understands both color (for the line itself) and fill (for the shaded standard error ribbon) (Healy, 2018). Each of these elements is representedi n the legend: the point color, the line color, and the ribbon fill \[Figure 6.34\].

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image013.png)

Figure 6.34: Legend that faithfully reflects the mappings for the chart: color, dots, lines, and fill.

In the legend for Figure 6.34, we see several visual elements. The key for each continent shows a dot, a line, and a filled background for the eror bars.

Let us try this with another graph.

p \<- ggplot(data = gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) p + geom_point(mapping = aes(color = continent)) + geom_smooth(method = "loess") + scale_x\_log10()

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image011.png)

Figure 6.35: Mapping aesthetics on a per-geom basis. Here color is mapped to continent for the points but not the smoother

![](file:////Users/douglasjoubert/Library/Group%2520Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image014.png)

Figure 6.36: Legend that faithfully reflects the mappings for the chart: dots, lines, and color.

The key for Figure 6.36, has only a dot for each continent, with no shaded background or line.

If you look again at the code for Figures L4.35 and L4.36, you will see that in the L4.35 we mapped the continent variable to both color and fill. We then drew the graph with geom_point() and fitted a line for each continent with geom_smooth(). In L4.35 points have color but the smoother understands both color (for the line itself) and fill (for the shaded standard error ribbon).

In contrast, in L4.35 we decided to simplify things by having only the points be colored by continent. Then we drew just a single smoother for the whole graph. Thus, in the legend for that figure, the colored line and the shaded box are both absent. We only see a legend for the mapping of color to continent in geom_point().

# Additional Resources

Many of these concepts are from a book by Leland Wilkinson, which have been summarized in a book by Hadley Wickham Figure 6.22. The [*book*](https://ebookcentral.proquest.com/lib/cua/detail.action?docID=4546676) is available from the CUA library, and it is also available [*online*](https://ggplot2-book.org/).

# Examples from Class

### Example 1: col = respondent_wall_type in ggplot statement (Doug Version)

```{r Example 1}
interviews_plotting %>% 
  ggplot(mapping = aes(x = village, y = rooms)) +
  geom_jitter(mapping = aes(col = respondent_wall_type))
```

### Example 1: Implications when you add another layer (Doug version)

```{r Example 1: Modifications}
interviews_plotting %>% 
  ggplot(mapping = aes(x = village, y = rooms)) +
  geom_jitter(mapping = aes(col = respondent_wall_type)) +
  geom_violin(alpha = 0.5)
  
```

## Example 2: col = respondent_wall_type in ggplot statement (Other Version)

```{r Example 2}
interviews_plotting %>% 
  ggplot(mapping = aes(x = village, y = rooms, col = respondent_wall_type)) +
  geom_jitter()
```

### Example 2: Implications when you add another layer (Other Version)

```{r Example 2: Modifications}
interviews_plotting %>% 
  ggplot(mapping = aes(x = village, y = rooms, col = respondent_wall_type)) +
  geom_jitter() +
  geom_violin(alpha = 0.5)
```
