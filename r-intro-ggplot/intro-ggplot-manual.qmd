---
title: "Introduction to ggplot"
author: "Doug Joubert"
author: "Doug Joubert"
date: "`r Sys.Date()`"
format: docx
editor: visual
toc: true
toc-location: body
fig-width: 6
fig-height: 4
bibliography: nihl-r-classes.bib
csl: apa.csl
---

# Learning Objectives

By the end of this section, students should be able to:

1.  Discuss the connection between data, aesthetics, & the grammar of graphics
2.  Outline the grammatical layers in ggplot
3.  Label the basic elements of a graph
4.  Distinguish between "viewing" a graph in R and saving a graph in R.

# Semiotics of Graphics

Semiotics is the study of symbols and how they convey meaning. In his great masterwork, Semiology of Graphics, Bertin (1983) attempted to classify all graphic marks in terms of how they could express data.

For the most part, this work is based on his own judgment, although it is a highly trained and sensitive judgment. There are few references to theories of perception or scientific studies.

![](images/three-symbols-visual.png) Figure 1: Examples of different visual "languages" [@RN1346].

The first example of visual language is based on a cave painting. We can readily interpret that these are animal.

The second example is a schematic diagram showing the interaction between lab equipment and some sort of medium.

The third example is the expression of a mathematical equation that is utterly obscure to all but the initiated.

These examples clearly show that some visual languages are easier to "read" than others. But why?

-   Perhaps it is simply that we have more experience with the kind of pictorial image shown in the cave painting and less with the mathematical notation.

-   Perhaps the concepts expressed in the cave painting are more familiar than those in the equation.

# Coordinate systems and axes

To make any sort of data visualization, we need to define position scales, which determine where in a graphic different data values are located [@RN1397]. We cannot visualize data without placing different data points at different locations, even if we just arrange them next to each other along a line.

In 2D visualizations, two numbers are required to uniquely specify a point, and therefore we need two position scales [@RN1397]. These two scales are usually the x and y axes of the plot [@RN1397]. We also have to specify the relative geometric arrangement of these scales [@RN1397].

## Cartesian Coordinates

The most widely used coordinate system for data visualization is the 2D Cartesian coordinate system, where each location is uniquely specified by an x and a y value [@RN1397]. As illustrated in Figure 2, the data values are placed in an even spacing along both axes, the two axes are continuous position scales, and they can represent both positive and negative real numbers [@RN1397].

![](ggplot-images/cartesian-coord-1.png){width="4.5in"}

Figure 2: Standard Cartesian coordinate system [@RN1397].

In Figure 2, both the x and the y grid lines are separated by units of one, and the x axis runs from -2.2 to 3.2 and the y axis runs from -2.2 to 2.2 [@RN1397]. Any data values between these axis limits are placed at the respective location in the plot. Any data values outside the axis limits are discarded [@RN1397].

It is important to remember that data values usually aren't just numbers, they come with units [@RN1397]. For example, if we're measuring temperature, the values may be measured in degrees Celsius or Fahrenheit [@RN1397]. Similarly, if we're measuring distance, the values may be measured in kilometers or miles [@RN1397].

You may wonder what happens if you change the units of your data. A change in units is a linear transformation, where we add or subtract a number to or from all data values and/or multiply all data values with another number [@RN1397].

Therefore, you can change the units of your data and the resulting figure will not change if you change the axes accordingly. As an example, compare how the data is displayed in Figures 3 (a) and 3 (b).

![](images/temperature-normals-Houston-San-Diego-1.png)

Figure 3: Daily (normal) temperature for Houston, TX, plotted versus the (normal) temperature of San Diego, CA (Wilke, 2019). Data source: NOAA.

## Nonlinear Axes and Log Transformations

In a Cartesian coordinate system, the grid lines along an axis are spaced evenly both in data units and in the resulting visualization. We refer to the position scales in these coordinate systems as linear [@RN1397].

There are scenarios where nonlinear scales are preferred. The most used nonlinear scale is the logarithmic scale, or log scale for short [@RN1397]. Log scales are linear in multiplication, such that a unit step on the scale corresponds to multiplication with a fixed value [@RN1397].

Importantly, the correct axis title for a logarithmic scale is the name of the variable shown, not the logarithm of that variable.

It is always recommended that you verify the base when working with log-transformed data [@RN1397]. When plotting log-transformed data, always specify the base in the labeling of the axis, to avoid confusion.

Log scales are the natural choice for any data that has been obtained by multiplication or division. For example, ratios should generally be shown on a log scale [@RN1397]. As an example, in Figure 4, the number of inhabitants in each county in Texas was divided by the median number of inhabitants across all Texas counties \[Figure 4\].

![](images/texas-counties-pop-ratio-log-1.png) [@RN1397]

Figure 4: Texas counties, from most to least populous using a log scale 10 transformation [@RN1397].

Look how different the same data appears when graph using a linear scale. Using a linear scale obscures the differences between a county with median population number and a county with a much smaller population number than median \[Figure 5\] [@RN1397].

![](images/texas-counties-pop-ratio-lin-1.png)

Figure 5: Texas counties, from most to least populous, using a linear transformation (Wilke, 2019).

Log scales are frequently used when the dataset contains numbers of very different magnitudes [@RN1397]. For the Texas counties shown in Figures 4 and 5, the most populous one (Harris) had 4,092,459 inhabitants in the 2010 US Census while the least populous one (Loving) had 82 [@RN1397]. So, a log scale would be appropriate even if we hadn't divided the population numbers by their median to turn them into ratios [@RN1397].

# Loading our Packages

## Tidyverse Package

For this lesson we will use the gapminder data to make our first plots. So we need to make sure the library containing the data is loaded, along with the tidyverse. A brief definition of each package is provided below:

The tidyverse is an opinionated [**collection of R packages**](https://www.tidyverse.org/packages) designed for data science. All packages share an underlying design philosophy, grammar, and data structures.

Install the complete tidyverse with:

    install.packages("tidyverse")

## Gapminder Package

Excerpt from the [**Gapminder**](http://www.gapminder.org/data/) data. The main object in this package is the **`gapminder`** data frame or "tibble". There are other goodies, such as the data in tab delimited form, a larger unfiltered dataset, premade color schemes for the countries and continents, and ISO 3166-1 country codes.

The **`gapminder`** data frames include six variables, ([**Gapminder.org documentation page**](http://www.gapminder.org/data/documentation/)).

Install the gapminder package with:

    install.packages("gapminder")

The **nlme: Nonlinear Mixed-Effects Models** package fits a nonlinear mixed-effects model in the formulation described in Lindstrom and Bates (1990) but allowing for nested random effects. The within-group errors are allowed to be correlated and/or have unequal variances. We are simply using it for the [oxboys](https://rdrr.io/cran/mlmRev/man/Oxboys.html) dataset.

Now, we can load the packages

```{r}
#| output: false
library(tidyverse)
library(gapminder)
library(nlme)
```

# How ggplot Works

ggplot is built on the grammar of graphics, the idea that any plot can be expressed from the same set of components [@RN1510]. ggplot2 is designed to work iteratively. You start with a layer that shows the raw data. Then you add layers of annotations and statistical summaries [@RN1510].

All plots are composed of the **data**, the information you want to visualize, and a **mapping**. The mapping is the description of how the data's variables are mapped to aesthetic attributes. There are five mapping components [@RN1510]:

1.  **Layer** is a collection of geometric elements and statistical transformations. Geometric elements, **geom**s for short, represent what you actually see in the plot Statistical transformations, **stat**s for short, summarise the data.
2.  **Scale**s map values in the data space to values in the aesthetic space. This includes the use of colour, shape or size. Scales also draw the legend and axes, which make it possible to read the original data values from the plot.
3.  **Coord**, or coordinate system, describes how data coordinates are mapped to the plane of the graphic. It also provides axes and gridlines to help read the graph. We normally use the Cartesian coordinate system, but a number of others are available, including polar coordinates and map projections.
4.  **Facet** specifies how to break up and display subsets of data as small multiples
5.  Coordinate system
6.  Aesthetic attributes of ggplot to display the visual property of your graph. For example the position, shape, or color elements on the graph
7.  Set of geoms, the visual representation of data points.
8.  **Theme** controls the finer points of display, like the font size and background colour.

The most important thing to get used is mapping out the logical structure of your plot [@RN1461]. The code you write specifies the connections between the variables in your data, and the colors, points, and shapes you see on the screen [@RN1461].

In ggplot, these logical connections between your data and the plot elements are called aesthetic mappings or just aesthetics [@RN1461]. You begin every plot by telling the `ggplot()` function what your data is and how the variables in this data logically map onto the plot's aesthetics [@RN1461].

To build a ggplot, we will use a basic template that can be used for different types of plots.

`ggplot(data = DATA, mapping = aes(AESTHETIC MAPPINGS)) + geom_function()`

# Key Components

Every ggplot2 plot has three key components:

1.  **Data**

2.  **Aesthetic mappings** between variables in the data and visual properties.

3.  At least one layer which describes how to render each observation. Layers are usually created with a **geom** function.

## Data

Every layer must have some data associated with it, and that data must be in a tidy data frame. Tidy data frames are described in more detail in [R for Data Science](https://r4ds.had.co.nz/), but for now, all you need to know is that a tidy data frame has variables in the columns and observations in the rows [@RN1511].

You begin every plot by telling the `ggplot()` function what your data is. We will be implementing this using pipes. Let us add the first component (data) using data that is part of the gapminder package:

```{r}
gapminder %>% 
  ggplot()
```

Nothing is really displaying. However, the gapminder variables are all available for plotting.

| **country** | **continent** | **year** | **lifeExp** | **pop**  | **gdpPercap** |
|:------------|:--------------|:---------|:------------|:---------|:--------------|
| Afghanistan | Asia          | 1952     | 28.801      | 8425333  | 779.4453      |
| Afghanistan | Asia          | 1957     | 30.332      | 9240934  | 820.8530      |
| Afghanistan | Asia          | 1962     | 31.997      | 10267083 | 853.1007      |
| Afghanistan | Asia          | 1967     | 34.020      | 11537966 | 836.1971      |
| Afghanistan | Asia          | 1972     | 36.088      | 13079460 | 739.9811      |

## Aesthetics Mapping

Each geom function in ggplot2 takes a mapping argument, `mapping =`.

This defines how variables in your dataset are mapped to visual properties. The mapping argument is always paired with `aes()`:

`mapping = aes()`

`aes()` allows us to select the variables to be plotted and specify how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, or color.

Let us add `aes()` to our plot. Before we do this, let us take a peek at the data.

```{r}
#| output: false
glimpse(gapminder)
```

We are going to plot the following variables from the nyc data, which we will place inside the mapping function. Let us plot `lifeExp` against `gdpPercap`.

Let us add `aes()` to our plot. We are going to plot the following variables, which we will place inside the (x = gdpPercap, y = lifeExp), and save this to the p object.

```{r}
gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp))
```

As we can see in the output above, `aes()` allows us to select the variables to be plotted and specify how to present them in the graph. As we can see from the output, the `ggplot()` function and already has information in it about the mappings we want, together with a lot of other information added by default [@RN1461].

So what have we done so far?

-   We have provided the `ggplot()` function two arguments: data and mapping. The data argument tells ggplot where to find the variables it is about to use. This saves us from having to tediously dig out the name of each variable in full.

-   Next, we supplied the `mapping` function. So, `mapping = aes(x = gdpPercap, y = lifeExp)` says that the variable on the x-axis is going to be `gdpPercap`, and the variable on the y-axis is going to be `lifeExp`. The `aes() function` does not say where variables with those names are to be found. That's because ggplot() assumes that this comes from object given to the data argument [@RN1461].

The `mapping=aes()` argument links variables to things you will see on the plot [@RN1461]. The x and y values are the most obvious ones. However, other aesthetic mappings can include, color, shape, size, and line type (whether a line is solid, dashed) [@RN1461].

A mapping does not say what particular colors or shapes will be on the plot. Rather it says which variables in the data will be represented by visual elements like a color, a shape, or a point on the plot area [@RN1461].

### Mapping Aesthetics vs Setting Them

As we just learned, an *aesthetic mapping* specifies that a variable will be expressed by one of the available visual elements, such as size, or color, or shape. For example:

```{r}
map1 <- gapminder %>% 
  ggplot(mapping = aes(x=gdpPercap, y = lifeExp, color = continent))
```

What happens when we graph this?

```{r}
map1 + geom_point()
```

As you can see in the output, individual data points have been colored by continent, and a legend with a key to the colors has automatically been added to the plot. There is one for each unique value of the continent variable.

How do you think this code will be interpreted, when graphed?

```{r}
map2 <- gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp, color = "purple"))
```

```{r}
map2 + geom_point()
```

What has gone wrong here?

Why is there a legend saying "purple," and why have the points all turned pinkish-red instead of purple (Healy, 2018)? The aes () function is where that mapping is specified, and the function is trying to do its job (Healy, 2018). It wants to map a variable to the color aesthetic, so it assumes you are giving it a variable (Healy, 2018). aes() will do its best to treat "purple" as though it were a variable (Healy, 2018).

If we want to set a property, like color, we do it in the geom\_ we are using, and outside the mapping =aes (...) step. For example:

```{r}
map2 + geom_point(color = "purple")
```

As you can see from the output, setting the color attribute of the points directly, means that the "color" portion needs to go in the `geom`.

# Geoms in ggplot

Geometric objects, or **geoms** for short, perform the actual rendering of the layer, controlling the type of plot that you create [@RN1511]. For example, using a point geom will create a scatterplot, while using a line geom will create a line plot.

## Individual geoms

The geoms listed below are the fundamental building blocks of ggplot2. They are useful in their own right, but are also used to construct more complex geoms. Most of these geoms are associated with a named plot: when that geom is used by itself in a plot, that plot has a special name.

Each of these geoms is two dimensional and requires both `x` and `y` aesthetics. All of them understand `colour` (or `color`) and `size` aesthetics, and the filled geoms (bar, tile and polygon) also understand `fill`.

-   [`geom_area()`](https://ggplot2.tidyverse.org/reference/geom_ribbon.html) draws an **area plot**, which is a line plot filled to the y-axis (filled lines). Multiple groups will be stacked on top of each other.

-   [`geom_bar(stat = "identity")`](https://ggplot2-book.org/statistical-summaries.html#distributions) makes a **bar chart**. We need `stat = "identity"` because the default stat automatically counts values (so is essentially a 1d geom, see Section [5.4](https://ggplot2-book.org/statistical-summaries.html#distributions). The identity stat leaves the data unchanged. Multiple bars in the same location will be stacked on top of one another.

-   [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) makes a **line plot**. The `group` aesthetic determines which observations are connected; see Chapter [4](https://ggplot2-book.org/collective-geoms.html#collective-geoms) for more detail. [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) connects points from left to right; [`geom_path()`](https://ggplot2.tidyverse.org/reference/geom_path.html) is similar but connects points in the order they appear in the data. Both [`geom_line()`](https://ggplot2.tidyverse.org/reference/geom_path.html) and [`geom_path()`](https://ggplot2.tidyverse.org/reference/geom_path.html) also understand the aesthetic `linetype`, which maps a categorical variable to solid, dotted and dashed lines.

-   [`geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) produces a **scatterplot**. [`geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html) also understands the `shape` aesthetic.

-   [`geom_polygon()`](https://ggplot2.tidyverse.org/reference/geom_polygon.html) draws polygons, which are filled paths. Each vertex of the polygon requires a separate row in the data. It is often useful to merge a data frame of polygon coordinates with the data just prior to plotting. Section [6](https://ggplot2-book.org/maps.html#maps) illustrates this concept in more detail for map data.

So, a basic plot might looks something like this

```{r}
gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp)) +
  geom_point()
```

If we want to map the data to the different aesthetics, it might look like this.

| **Data**                 | **Variable** | **aes** | **geom**   |
|--------------------------|--------------|---------|------------|
| Weatlh (GGP/capita)      | gdpPercap    | x       | geom_point |
| Health (Life Expectancy) | lifeExp      | y       | geom_point |
| Continent                | country      | Color   | geom_point |
| Population               | pop          | Size    | geom_point |

```{r}
gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp, color = continent, size = pop)) +
  geom_point() +
  scale_x_log10() # changes x-axis to be on the log scale, because of
# gaps in countries
```

## Collective Geoms in ggplot

An **individual** `geom` draws a distinct graphical object for each observation (row). For example, the point geom draws one point per row. A **collective** `geom` displays multiple observations with one geometric object. This may be a result of a statistical summary, like a boxplot, or may be fundamental to the display of the geom, like a polygon. How do we control the assignment of observations to graphical elements? This is the job of the `group` aesthetic.

By default, the `group` aesthetic is mapped to the interaction of all discrete variables in the plot. This often partitions the data correctly. However, when the mapping is not automatic, or when no discrete variable is used in a plot, you'll need to explicitly define the grouping structure to a variable that has a different value for each group.

In the following examples, we will use a simple longitudinal dataset, [Oxboys](https://rdrr.io/cran/nlme/man/Oxboys.html) which is included in the `nlme`package. It looks at the height of a selection of boys from Oxford, England versus a standardized age. It records the heights (`height`) and centered ages (`age`) of 26 boys (`Subject`), measured on nine occasions (`Occasion`). `Subject` and `Occassion` are stored as ordered factors.

```{r}
#| output: false
glimpse(Oxboys)
```

### Multiple groups, one aesthetic

In many situations, you want to separate your data into groups, but render them in the same way. In other words, you want to be able to distinguish individual subjects, but not identify them. This is common in longitudinal studies with many subjects, where the plots are often descriptively called spaghetti plots. For example, the following plot shows the growth trajectory for each boy (each `Subject`). Without grouping, ggplot will make its best judgement, when displaying the graph

```{r}
Oxboys %>%
  ggplot(mapping = aes(x = age, y = height)) + 
  geom_line()
```

This is certainly not what we want, and we get a graph that has a saw tooth appearance:

```{r}
Oxboys %>% 
ggplot(mapping = aes(x = age, y = height, group = Subject)) + 
  geom_line()
```

## Aesthetics Can Be Mapped per Geom

By default, `geoms` inherit their mappings from the `ggplot()` function. We can change this by specifying different aesthetics for each geom. To do this, we use the same `mapping = aes(â€¦)` expression. However, this time we use it in the `geom_ functions`.

```{r}
plot3 <- gapminder %>% 
  ggplot(mapping = aes(x = gdpPercap, y = lifeExp))
```

Mappings specified in the initial `ggplot( )` function (x and y) will carry through to all subsequent `geoms`. The code block below is illustrating how to map aesthetics on a per geom basis.

```{r}
plot3 +
  geom_point(aes(color = continent)) +
  geom_smooth(method = "loess") +
  scale_x_log10()
```

As you can see in the output, color is mapped to the continent variable for the points but not the smoother.

Finally, it is worth paying a little more attention to the way that ggplot draws its scales (Healy, 2018). Because every mapped variable has a scale, we can learn a lot about how a plot has been constructed, by seeing what the legends look like (Healy, 2018). For example:

```{r}
plot4 <- gapminder %>% 
  ggplot(aes(x = gdpPercap, y = lifeExp, color = continent, fill = continent))
```

Now, we add our geom:

```{r}
plot4 +
  geom_point() +
  geom_smooth(method = "loess") + scale_x_log10()
```

In this example, we mapped the continent variable to both color and fill. We then drew the figure with `geom_point()` and fitted a line for each continent with `geom_smooth()`.

Points have color but the smoother understands both color (for the line itself) and fill (for the shaded standard error ribbon) [@RN1358]. Each of these elements is represented in the legend: the point color, the line color, and the ribbon fill.

In the legend for this figure we see several visual elements. The key for each continent shows a dot, a line, and a filled background for the error bars.

Let us try this with another graph.

```{r}
plot5 <- gapminder %>% 
  ggplot(aes(x = gdpPercap, y = lifeExp))
```

Now, let us add our `geoms`

```{r}
plot5 +
  geom_point(aes(color = continent)) +
  geom_smooth(method = "loess") +
  scale_x_log10()
```

This figure is different because we are mapping teh aesthetics on a per-geom basis. Here color is mapped to continent for the points but not the smoother.

The legend for this figure has a dot for each continent, with no shaded background or line.

## Geoms for One variable

### Discrete

-   [`geom_bar()`](https://ggplot2.tidyverse.org/reference/geom_bar.html): display distribution of discrete variable.

### Continuous

-   [`geom_histogram()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html): bin and count continuous variable, display with bars.

-   [`geom_density()`](https://ggplot2.tidyverse.org/reference/geom_density.html): smoothed density estimate.

-   [`geom_dotplot()`](https://ggplot2.tidyverse.org/reference/geom_dotplot.html): stack individual points into a dot plot.

-   [`geom_freqpoly()`](https://ggplot2.tidyverse.org/reference/geom_histogram.html): bin and count continuous variable, display with lines.

## Geoms for Two variables

### Two Continuous Variables

-   [`geom_point()`](https://ggplot2.tidyverse.org/reference/geom_point.html): scatterplot.

-   [`geom_quantile()`](https://ggplot2.tidyverse.org/reference/geom_quantile.html): smoothed quantile regression.

-   [`geom_smooth()`](https://ggplot2.tidyverse.org/reference/geom_smooth.html): smoothed line of best fit.

-   [`geom_text()`](https://ggplot2.tidyverse.org/reference/geom_text.html): text labels.

### Showing Distributions with Two Variables

-   [`geom_bin2d()`](https://ggplot2.tidyverse.org/reference/geom_bin_2d.html): bin into rectangles and count.

-   [`geom_density2d()`](https://ggplot2.tidyverse.org/reference/geom_density_2d.html): smoothed 2d density estimate.

-   [`geom_hex()`](https://ggplot2.tidyverse.org/reference/geom_hex.html): bin into hexagons and count.

### At Least One Discrete Variable

-   [`geom_count()`](https://ggplot2.tidyverse.org/reference/geom_count.html): count number of point at distinct locations

-   [`geom_jitter()`](https://ggplot2.tidyverse.org/reference/geom_jitter.html): randomly jitter overlapping points.

### One continuous Variable and One Discrete Variable

-   `geom_bar(stat = "identity")`: a bar chart of precomputed summaries.

-   [`geom_boxplot()`](https://ggplot2.tidyverse.org/reference/geom_boxplot.html): boxplots.

-   [`geom_violin()`](https://ggplot2.tidyverse.org/reference/geom_violin.html): show density of values in each group.

# Build Your Plots Layer by Layer

As previously noted, the general structure of layers used to plot figures is as follows:

    ggplot(...)+ # Initialization
    geom_function(...)+ # Main plot(s)
    facet_function(...)+ # Facets (optional)
    labs(...)+ #  Legend (optional)
    scale_function(...) + # Scales (optional)
    theme_function(...) # Theme (optional)

What to consider, when working with these layers:

-   The `ggplot()` layer is mandatory.

-   When the `data` argument is specified inside the `ggplot()` function, it is used as default in the following layers that compose the plot command, unless otherwise specified.

-   In order for features of a data frame to be used in a plot, they need to be specified inside the `aes()` function.

# Additional Resources

Many of these concepts are from a book by Leland Wilkinson, which have been summarized in a book by Hadley Wickham. The [book](https://ebookcentral.proquest.com/lib/cua/detail.action?docID=4546676) is available from the CUA library, and it is also available [online](https://ggplot2-book.org/).
